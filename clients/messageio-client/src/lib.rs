#![allow(unused)]

use std::collections::VecDeque;
use std::sync::mpsc::channel;
use std::time::Duration;

use async_trait::async_trait;
use fnv::FnvHashMap;
use log::{debug, error, info};
use message_io::network::{Endpoint, NetEvent};
use message_io::node;
use message_io::node::{NodeEvent, NodeHandler, NodeListener};
use tokio::sync::mpsc::UnboundedReceiver;
use tokio::sync::{broadcast, mpsc};
use tokio::time::Instant;

use bigworlds::net::{CompositeAddress, Encoding, Transport};
use bigworlds::rpc::msg::{
    AdvanceRequest, Message, RegisterClientRequest, StatusRequest, StatusResponse,
};
use bigworlds::{client, EntityName, PrefabName};
use bigworlds::{net, Error, Query, QueryProduct};
use tokio_util::sync::CancellationToken;

pub struct Client {
    handler: NodeHandler<()>,
    endpoint: Endpoint,

    queue: broadcast::Receiver<Message>,
}

#[async_trait]
impl bigworlds::client::r#async::AsyncClient for Client {
    type Client = Client;

    async fn connect(
        c_addr: CompositeAddress,
        config: client::Config,
    ) -> bigworlds::Result<Self::Client> {
        let cancel = CancellationToken::new();

        let (handler, listener) = node::split::<()>();

        let (sender, receiver) = tokio::sync::broadcast::channel(10);

        let handler_c = handler.clone();
        let mut cancel_c = cancel.clone();
        tokio::spawn(async move {
            cancel_c.cancelled().await;
            handler_c.signals().send(());
        });

        let handler_c = handler.clone();
        let config = config.clone();
        tokio::spawn(async move {
            listener.for_each_async(move |event| match event {
                NodeEvent::Network(net_event) => match net_event {
                    NetEvent::Connected(_endpoint, _ok) => {
                        if _ok {
                            let req = Message::RegisterClientRequest(RegisterClientRequest {
                                name: "messageio-client".to_string(),
                                is_blocking: config.is_blocking,
                                auth_pair: None,
                                encodings: vec![Encoding::Bincode],
                                transports: vec![Transport::FramedTcp],
                            });
                            let req = serde_json::to_vec(&req).unwrap();
                            // let req = bincode::serialize(&req).unwrap();
                            handler_c.network().send(_endpoint, &req);
                            debug!("sent registration request to server...");
                        } else {
                            info!("failed establishing connection");
                            cancel.cancel();
                        }
                    }
                    NetEvent::Accepted(_, _) => unreachable!(), // Only generated by listening
                    NetEvent::Message(_endpoint, data) => match bincode::deserialize(data) {
                        Ok(msg) => {
                            if let Message::RegisterClientResponse(_) = &msg {
                                // connection established
                                println!("got register client response, connection established");
                            } else {
                                sender.send(msg).map(|_| ()).unwrap();
                            }
                        }
                        Err(e) => {
                            error!("failed deserializing response: {:?}", e);
                            cancel.cancel();
                        }
                    },
                    NetEvent::Disconnected(_endpoint) => (),
                },
                NodeEvent::Signal(_) => {
                    handler_c.stop();
                    return;
                }
                _ => unimplemented!(),
            });
        });

        let (endpoint, _) = handler.network().connect(
            from_transport(c_addr.transport.unwrap_or(Transport::FramedTcp)),
            if let net::Address::Net(addr) = c_addr.address {
                if c_addr.transport == Some(Transport::WebSocket) {
                    format!("ws://{addr}/ws")
                } else {
                    format!("ws://{addr}")
                }
            } else {
                panic!("address format not supported: {}", c_addr.address);
            },
        )?;

        tokio::time::sleep(Duration::from_millis(10)).await;

        let client = Self::Client {
            handler,
            endpoint,
            queue: receiver,
        };

        Ok(client)
    }

    async fn shutdown(&mut self) -> bigworlds::Result<()> {
        self.handler.stop();
        Ok(())
    }

    async fn is_alive(&mut self) -> bigworlds::Result<()> {
        self.handler
            .is_running()
            .then_some(())
            .ok_or(Error::Other("ws: client disconnected".to_owned()))
    }

    async fn initialize(&mut self) -> bigworlds::Result<()> {
        todo!()
    }
    async fn spawn_entity(
        &mut self,
        name: EntityName,
        prefab: Option<PrefabName>,
    ) -> bigworlds::Result<()> {
        todo!()
    }
    async fn despawn_entity(&mut self, name: &str) -> bigworlds::Result<()> {
        todo!()
    }

    async fn get_model(&mut self) -> bigworlds::Result<bigworlds::Model> {
        todo!()
    }
    async fn status(&mut self) -> bigworlds::Result<StatusResponse> {
        let req = Message::StatusRequest(StatusRequest {
            format: "".to_string(),
        });
        let req = bincode::serialize(&req)?;
        self.handler.network().send(self.endpoint, &req);
        let start = Instant::now();
        loop {
            // tokio::time::sleep(Duration::from_millis(3)).await;
            // self.queue
            // if let Message::StatusResponse(_) = self.queue.front() {
            //     let (n, msg) = self.queue.iter().next().unwrap();
            // }

            if let Ok(msg) = self.queue.recv().await {
                if let Message::StatusResponse(sr) = msg {
                    return Ok(sr.clone());
                }
            } else {
                if start.elapsed() > Duration::from_secs(3) {
                    return Err(bigworlds::Error::Timeout);
                } else {
                    continue;
                }
            }
        }
    }

    async fn step(&mut self, step_count: u32) -> bigworlds::Result<()> {
        let req = Message::AdvanceRequest(AdvanceRequest {
            step_count,
            wait: true,
        });
        let req = bincode::serialize(&req)?;
        self.handler.network().send(self.endpoint, &req);
        let start = Instant::now();
        loop {
            // tokio::time::sleep(Duration::from_millis(3)).await;
            // self.queue
            // if let Message::StatusResponse(_) = self.queue.front() {
            //     let (n, msg) = self.queue.iter().next().unwrap();
            // }

            if let Ok(msg) = self.queue.recv().await {
                if let Message::AdvanceResponse(resp) = msg {
                    if resp.error.is_empty() {
                        return Ok(());
                    } else {
                        error!("{}", resp.error)
                    }
                }
            } else {
                if start.elapsed() > Duration::from_secs(3) {
                    return Err(bigworlds::Error::Timeout);
                } else {
                    continue;
                }
            }
        }
        Ok(())
    }

    // TODO: provide a way to pass query object by reference
    async fn query(&mut self, q: Query) -> bigworlds::Result<QueryProduct> {
        self.send_msg(&Message::QueryRequest(q))?;
        let resp = self
            .queue
            .recv()
            .await
            .map_err(|e| Error::Other(format!("{:?}", e)))?;

        match resp {
            Message::QueryResponse(product) => Ok(product),
            _ => panic!("unexpected response: {:?}", resp),
        }
    }
}

impl Client {
    fn send_msg(&mut self, msg: &Message) -> bigworlds::Result<()> {
        self.handler
            .network()
            .send(self.endpoint, &msg.to_bytes(Encoding::Bincode)?);
        Ok(())
    }

    async fn recv_msg(&mut self) -> bigworlds::Result<Message> {
        self.queue
            .recv()
            .await
            .map_err(|e| Error::Other(format!("{:?}", e)))
    }

    fn try_recv_msg(&mut self) -> bigworlds::Result<Message> {
        if let Ok(msg) = self.queue.try_recv() {
            Ok(msg)
        } else {
            Err(Error::WouldBlock)
        }
    }
}

fn from_transport(t: Transport) -> message_io::network::Transport {
    match t {
        Transport::FramedTcp => message_io::network::Transport::FramedTcp,
        Transport::WebSocket => message_io::network::Transport::Ws,
        _ => unimplemented!("transport not supported: {}", t),
    }
}
